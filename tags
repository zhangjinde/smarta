!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AE_ALL_EVENTS	src/ae.h	/^#define AE_ALL_EVENTS /;"	d
AE_DONT_WAIT	src/ae.h	/^#define AE_DONT_WAIT /;"	d
AE_ERR	src/ae.h	/^#define AE_ERR /;"	d
AE_FILE_EVENTS	src/ae.h	/^#define AE_FILE_EVENTS /;"	d
AE_NOMORE	src/ae.h	/^#define AE_NOMORE /;"	d
AE_NONE	src/ae.h	/^#define AE_NONE /;"	d
AE_NOTUSED	src/ae.h	/^#define AE_NOTUSED(/;"	d
AE_OK	src/ae.h	/^#define AE_OK /;"	d
AE_READABLE	src/ae.h	/^#define AE_READABLE /;"	d
AE_SETSIZE	src/ae.h	/^#define AE_SETSIZE /;"	d
AE_TIME_EVENTS	src/ae.h	/^#define AE_TIME_EVENTS /;"	d
AE_WRITABLE	src/ae.h	/^#define AE_WRITABLE /;"	d
AF_LOCAL	src/anet.h	/^#define AF_LOCAL /;"	d
AL_START_HEAD	src/list.h	/^#define AL_START_HEAD /;"	d
AL_START_TAIL	src/list.h	/^#define AL_START_TAIL /;"	d
ANET_CONNECT_NONBLOCK	src/anet.c	/^#define ANET_CONNECT_NONBLOCK /;"	d	file:
ANET_CONNECT_NONE	src/anet.c	/^#define ANET_CONNECT_NONE /;"	d	file:
ANET_ERR	src/anet.h	/^#define ANET_ERR /;"	d
ANET_ERR_LEN	src/anet.h	/^#define ANET_ERR_LEN /;"	d
ANET_OK	src/anet.h	/^#define ANET_OK /;"	d
Buddy	src/xmpp.h	/^} Buddy;$/;"	t	typeref:struct:_Buddy
CONFIGLINE_MAX	src/smarta.c	/^#define CONFIGLINE_MAX /;"	d	file:
Command	src/smarta.h	/^} Command;$/;"	t	typeref:struct:_Command
Event	src/event.h	/^} Event;$/;"	t	typeref:struct:_Event
F1	src/md5.c	/^#define F1(/;"	d	file:
F2	src/md5.c	/^#define F2(/;"	d	file:
F3	src/md5.c	/^#define F3(/;"	d	file:
F4	src/md5.c	/^#define F4(/;"	d	file:
GET_32BIT_LSB_FIRST	src/md5.c	/^#define GET_32BIT_LSB_FIRST(/;"	d	file:
HAVE_BACKTRACE	src/config.h	/^#define HAVE_BACKTRACE /;"	d
HAVE_EPOLL	src/config.h	/^#define HAVE_EPOLL /;"	d
HAVE_KQUEUE	src/config.h	/^#define HAVE_KQUEUE /;"	d
HAVE_PROCFS	src/config.h	/^#define HAVE_PROCFS /;"	d
HAVE_TASKINFO	src/config.h	/^#define HAVE_TASKINFO /;"	d
HEARTBEAT_TIMEOUT	src/smarta.c	/^#define HEARTBEAT_TIMEOUT /;"	d	file:
Hash	src/hash.h	/^typedef struct _Hash Hash;$/;"	t	typeref:struct:_Hash
IN_COMMAND_BLOCK	src/smarta.c	/^#define IN_COMMAND_BLOCK /;"	d	file:
IN_SERVICE_BLOCK	src/smarta.c	/^#define IN_SERVICE_BLOCK /;"	d	file:
IN_SMARTA_BLOCK	src/smarta.c	/^#define IN_SMARTA_BLOCK /;"	d	file:
LOG_DEBUG	src/logger.h	/^    LOG_DEBUG = 0,  \/**< Debug levels.              *\/$/;"	e	enum:__anon1
LOG_ERROR	src/logger.h	/^    LOG_ERROR,    \/**< Errors.                        *\/$/;"	e	enum:__anon1
LOG_FATAL	src/logger.h	/^    LOG_FATAL \/**< Fatal errors.                  *\/$/;"	e	enum:__anon1
LOG_INFO	src/logger.h	/^    LOG_INFO,     \/**< General operation Information. *\/$/;"	e	enum:__anon1
LOG_WARNING	src/logger.h	/^    LOG_WARNING,  \/**< Warnings.                      *\/$/;"	e	enum:__anon1
LogLevel	src/logger.h	/^} LogLevel;$/;"	t	typeref:enum:__anon1
MAX_LOGMSG_LEN	src/xmpp.h	/^#define MAX_LOGMSG_LEN /;"	d
MAX_RETRIES	src/xmpp.c	/^#define MAX_RETRIES /;"	d	file:
MD5Context	src/md5.h	/^struct MD5Context {$/;"	s
MD5DumpBytes	src/md5.c	/^void MD5DumpBytes(unsigned char *b, int len) {$/;"	f
MD5Final	src/md5.c	/^void MD5Final(unsigned char digest[16], struct MD5Context *ctx) {$/;"	f
MD5Init	src/md5.c	/^void MD5Init(struct MD5Context *ctx) {$/;"	f
MD5STEP	src/md5.c	/^#define MD5STEP(/;"	d	file:
MD5Transform	src/md5.c	/^void MD5Transform(uint32_t buf[4], const unsigned char inext[64],$/;"	f
MD5Update	src/md5.c	/^void MD5Update(struct MD5Context *ctx, unsigned char const *buf, uint32_t len) {$/;"	f
PREFIX_SIZE	src/zmalloc.c	/^#define PREFIX_SIZE /;"	d	file:
PUT_32BIT_LSB_FIRST	src/md5.c	/^#define PUT_32BIT_LSB_FIRST(/;"	d	file:
Parser	src/parser.h	/^typedef struct _Parser Parser;$/;"	t	typeref:struct:_Parser
R0	src/sha1.c	/^#define R0(/;"	d	file:
R1	src/sha1.c	/^#define R1(/;"	d	file:
R2	src/sha1.c	/^#define R2(/;"	d	file:
R3	src/sha1.c	/^#define R3(/;"	d	file:
R4	src/sha1.c	/^#define R4(/;"	d	file:
SASL_MASK_ANONYMOUS	src/xmpp.h	/^#define SASL_MASK_ANONYMOUS /;"	d
SASL_MASK_DIGESTMD5	src/xmpp.h	/^#define SASL_MASK_DIGESTMD5 /;"	d
SASL_MASK_PLAIN	src/xmpp.h	/^#define SASL_MASK_PLAIN /;"	d
SHA1_CTX	src/sha1.h	/^} SHA1_CTX;$/;"	t	typeref:struct:__anon2
SHA1_DIGEST_SIZE	src/sha1.h	/^#define SHA1_DIGEST_SIZE /;"	d
SHA1_Final	src/sha1.c	/^void SHA1_Final(SHA1_CTX* context, uint8_t digest[SHA1_DIGEST_SIZE]) {$/;"	f
SHA1_Init	src/sha1.c	/^void SHA1_Init(SHA1_CTX* context) {$/;"	f
SHA1_Transform	src/sha1.c	/^void SHA1_Transform(uint32_t state[5], const uint8_t buffer[64]) {$/;"	f
SHA1_Update	src/sha1.c	/^void SHA1_Update(SHA1_CTX* context, const uint8_t* data, const size_t len)$/;"	f
SHAPrintContext	src/sha1.c	/^void SHAPrintContext(SHA1_CTX *context, char *msg){$/;"	f
SMARTA_VERSION	src/version.h	/^#define SMARTA_VERSION /;"	d
SUB_BOTH	src/xmpp.h	/^    SUB_BOTH,$/;"	e	enum:__anon6
SUB_FROM	src/xmpp.h	/^    SUB_FROM$/;"	e	enum:__anon6
SUB_TO	src/xmpp.h	/^    SUB_TO,$/;"	e	enum:__anon6
Service	src/smarta.h	/^} Service;$/;"	t	typeref:struct:_Service
Slave	src/slave.h	/^} Slave;$/;"	t	typeref:struct:_Slave
Smarta	src/smarta.h	/^} Smarta;$/;"	t	typeref:struct:_Smarta
Subscription	src/xmpp.h	/^} Subscription;$/;"	t	typeref:enum:__anon6
XMPP_EINT	src/xmpp.h	/^#define XMPP_EINT /;"	d
XMPP_EINVOP	src/xmpp.h	/^#define XMPP_EINVOP /;"	d
XMPP_EMEM	src/xmpp.h	/^#define XMPP_EMEM /;"	d
XMPP_NS_AUTH	src/xmpp.h	/^#define XMPP_NS_AUTH /;"	d
XMPP_NS_BIND	src/xmpp.h	/^#define XMPP_NS_BIND /;"	d
XMPP_NS_CLIENT	src/xmpp.h	/^#define XMPP_NS_CLIENT /;"	d
XMPP_NS_COMPONENT	src/xmpp.h	/^#define XMPP_NS_COMPONENT /;"	d
XMPP_NS_DISCO_INFO	src/xmpp.h	/^#define XMPP_NS_DISCO_INFO /;"	d
XMPP_NS_DISCO_ITEMS	src/xmpp.h	/^#define XMPP_NS_DISCO_ITEMS /;"	d
XMPP_NS_ROSTER	src/xmpp.h	/^#define XMPP_NS_ROSTER /;"	d
XMPP_NS_SASL	src/xmpp.h	/^#define XMPP_NS_SASL /;"	d
XMPP_NS_SESSION	src/xmpp.h	/^#define XMPP_NS_SESSION /;"	d
XMPP_NS_STREAMS	src/xmpp.h	/^#define XMPP_NS_STREAMS /;"	d
XMPP_NS_STREAMS_IETF	src/xmpp.h	/^#define XMPP_NS_STREAMS_IETF /;"	d
XMPP_NS_TLS	src/xmpp.h	/^#define XMPP_NS_TLS /;"	d
XMPP_OK	src/xmpp.h	/^#define XMPP_OK /;"	d
XMPP_SE_BAD_FORMAT	src/xmpp.h	/^    XMPP_SE_BAD_FORMAT,$/;"	e	enum:__anon4
XMPP_SE_BAD_NS_PREFIX	src/xmpp.h	/^    XMPP_SE_BAD_NS_PREFIX,$/;"	e	enum:__anon4
XMPP_SE_CONFLICT	src/xmpp.h	/^    XMPP_SE_CONFLICT,$/;"	e	enum:__anon4
XMPP_SE_CONN_TIMEOUT	src/xmpp.h	/^    XMPP_SE_CONN_TIMEOUT,$/;"	e	enum:__anon4
XMPP_SE_HOST_GONE	src/xmpp.h	/^    XMPP_SE_HOST_GONE,$/;"	e	enum:__anon4
XMPP_SE_HOST_UNKNOWN	src/xmpp.h	/^    XMPP_SE_HOST_UNKNOWN,$/;"	e	enum:__anon4
XMPP_SE_IMPROPER_ADDR	src/xmpp.h	/^    XMPP_SE_IMPROPER_ADDR,$/;"	e	enum:__anon4
XMPP_SE_INTERNAL_SERVER_ERROR	src/xmpp.h	/^    XMPP_SE_INTERNAL_SERVER_ERROR,$/;"	e	enum:__anon4
XMPP_SE_INVALID_FROM	src/xmpp.h	/^    XMPP_SE_INVALID_FROM,$/;"	e	enum:__anon4
XMPP_SE_INVALID_ID	src/xmpp.h	/^    XMPP_SE_INVALID_ID,$/;"	e	enum:__anon4
XMPP_SE_INVALID_NS	src/xmpp.h	/^    XMPP_SE_INVALID_NS,$/;"	e	enum:__anon4
XMPP_SE_INVALID_XML	src/xmpp.h	/^    XMPP_SE_INVALID_XML,$/;"	e	enum:__anon4
XMPP_SE_NOT_AUTHORIZED	src/xmpp.h	/^    XMPP_SE_NOT_AUTHORIZED,$/;"	e	enum:__anon4
XMPP_SE_POLICY_VIOLATION	src/xmpp.h	/^    XMPP_SE_POLICY_VIOLATION,$/;"	e	enum:__anon4
XMPP_SE_REMOTE_CONN_FAILED	src/xmpp.h	/^    XMPP_SE_REMOTE_CONN_FAILED,$/;"	e	enum:__anon4
XMPP_SE_RESOURCE_CONSTRAINT	src/xmpp.h	/^    XMPP_SE_RESOURCE_CONSTRAINT,$/;"	e	enum:__anon4
XMPP_SE_RESTRICTED_XML	src/xmpp.h	/^    XMPP_SE_RESTRICTED_XML,$/;"	e	enum:__anon4
XMPP_SE_SEE_OTHER_HOST	src/xmpp.h	/^    XMPP_SE_SEE_OTHER_HOST,$/;"	e	enum:__anon4
XMPP_SE_SYSTEM_SHUTDOWN	src/xmpp.h	/^    XMPP_SE_SYSTEM_SHUTDOWN,$/;"	e	enum:__anon4
XMPP_SE_UNDEFINED_CONDITION	src/xmpp.h	/^    XMPP_SE_UNDEFINED_CONDITION,$/;"	e	enum:__anon4
XMPP_SE_UNSUPPORTED_ENCODING	src/xmpp.h	/^    XMPP_SE_UNSUPPORTED_ENCODING,$/;"	e	enum:__anon4
XMPP_SE_UNSUPPORTED_STANZA_TYPE	src/xmpp.h	/^    XMPP_SE_UNSUPPORTED_STANZA_TYPE,$/;"	e	enum:__anon4
XMPP_SE_UNSUPPORTED_VERSION	src/xmpp.h	/^    XMPP_SE_UNSUPPORTED_VERSION,$/;"	e	enum:__anon4
XMPP_SE_XML_NOT_WELL_FORMED	src/xmpp.h	/^    XMPP_SE_XML_NOT_WELL_FORMED$/;"	e	enum:__anon4
XMPP_STANZA_CDATA	src/stanza.h	/^    XMPP_STANZA_CDATA,$/;"	e	enum:__anon3
XMPP_STANZA_TAG	src/stanza.h	/^    XMPP_STANZA_TAG,$/;"	e	enum:__anon3
XMPP_STANZA_TEXT	src/stanza.h	/^    XMPP_STANZA_TEXT,$/;"	e	enum:__anon3
XMPP_STANZA_UNKNOWN	src/stanza.h	/^    XMPP_STANZA_UNKNOWN = -1,$/;"	e	enum:__anon3
XMPP_STREAM_BINDED	src/xmpp.h	/^    XMPP_STREAM_BINDED,$/;"	e	enum:__anon5
XMPP_STREAM_BINDING	src/xmpp.h	/^    XMPP_STREAM_BINDING,$/;"	e	enum:__anon5
XMPP_STREAM_CONNECTING	src/xmpp.h	/^    XMPP_STREAM_CONNECTING,$/;"	e	enum:__anon5
XMPP_STREAM_DISCONNECTED	src/xmpp.h	/^    XMPP_STREAM_DISCONNECTED = 0,$/;"	e	enum:__anon5
XMPP_STREAM_ESTABLISHED	src/xmpp.h	/^    XMPP_STREAM_ESTABLISHED$/;"	e	enum:__anon5
XMPP_STREAM_SASL_AUTHED	src/xmpp.h	/^    XMPP_STREAM_SASL_AUTHED,$/;"	e	enum:__anon5
XMPP_STREAM_SASL_AUTHENTICATING	src/xmpp.h	/^    XMPP_STREAM_SASL_AUTHENTICATING,$/;"	e	enum:__anon5
XMPP_STREAM_SESSION_NEGOTIATING	src/xmpp.h	/^    XMPP_STREAM_SESSION_NEGOTIATING,$/;"	e	enum:__anon5
XMPP_STREAM_TLS_NEGOTIATING	src/xmpp.h	/^    XMPP_STREAM_TLS_NEGOTIATING,$/;"	e	enum:__anon5
XMPP_STREAM_TSL_OPENED	src/xmpp.h	/^    XMPP_STREAM_TSL_OPENED,$/;"	e	enum:__anon5
XmppErrorType	src/xmpp.h	/^} XmppErrorType;$/;"	t	typeref:enum:__anon4
XmppStanza	src/stanza.h	/^} XmppStanza;$/;"	t	typeref:struct:_XmppStanza
XmppStanzaType	src/stanza.h	/^} XmppStanzaType;$/;"	t	typeref:enum:__anon3
XmppStream	src/xmpp.h	/^typedef struct _XmppStream XmppStream;$/;"	t	typeref:struct:_XmppStream
XmppStreamError	src/xmpp.h	/^typedef struct _XmppStreamError XmppStreamError;$/;"	t	typeref:struct:_XmppStreamError
XmppStreamState	src/xmpp.h	/^} XmppStreamState;$/;"	t	typeref:enum:__anon5
_BSD_SOURCE	src/fmacros.h	/^#define _BSD_SOURCE$/;"	d
_Buddy	src/xmpp.h	/^typedef struct _Buddy {$/;"	s
_Command	src/smarta.h	/^typedef struct _Command {$/;"	s
_Event	src/event.h	/^typedef struct _Event {$/;"	s
_Hash	src/hash.c	/^struct _Hash {$/;"	s	file:
_POSIX_C_SOURCE	src/fmacros.h	/^#define _POSIX_C_SOURCE /;"	d
_Parser	src/parser.h	/^struct _Parser {$/;"	s
_Service	src/smarta.h	/^typedef struct _Service {$/;"	s
_Slave	src/slave.h	/^typedef struct _Slave {$/;"	s
_Smarta	src/smarta.h	/^typedef struct _Smarta {$/;"	s
_XOPEN_SOURCE	src/fmacros.h	/^#define _XOPEN_SOURCE /;"	d
_XOPEN_SOURCE	src/fmacros.h	/^#define _XOPEN_SOURCE$/;"	d
_XmppStanza	src/stanza.h	/^typedef struct _XmppStanza {$/;"	s
_XmppStream	src/xmpp.h	/^struct _XmppStream {$/;"	s
_XmppStreamError	src/xmpp.h	/^struct _XmppStreamError {$/;"	s
__ADLIST_H	src/list.h	/^#define __ADLIST_H$/;"	d
__AE_H	src/ae.h	/^#define __AE_H$/;"	d
__ANET_H	src/anet.h	/^#define __ANET_H$/;"	d
__CONFIG_H	src/config.h	/^#define __CONFIG_H$/;"	d
__EVENT_H	src/event.h	/^#define __EVENT_H$/;"	d
__FMACRO_H	src/fmacros.h	/^#define __FMACRO_H$/;"	d
__HASH_H	src/hash.h	/^#define __HASH_H$/;"	d
__JID_H	src/jid.h	/^#define __JID_H$/;"	d
__LOGGER_H	src/logger.h	/^#define __LOGGER_H$/;"	d
__MD5_H	src/md5.h	/^#define __MD5_H$/;"	d
__PARSER_H	src/parser.h	/^#define __PARSER_H$/;"	d
__SASL_H	src/sasl.h	/^#define __SASL_H$/;"	d
__SDS_H	src/sds.h	/^#define __SDS_H$/;"	d
__SHA1_H	src/sha1.h	/^#define __SHA1_H$/;"	d
__SLAVE_H	src/slave.h	/^#define __SLAVE_H$/;"	d
__SMARTA_H	src/smarta.h	/^#define __SMARTA_H$/;"	d
__STANZA_H	src/stanza.h	/^#define __STANZA_H$/;"	d
__XMPP_H	src/xmpp.h	/^#define __XMPP_H$/;"	d
__ZMALLOC_H	src/zmalloc.h	/^#define __ZMALLOC_H$/;"	d
__failed_tests	src/sds.c	/^int __failed_tests = 0;$/;"	v
__test_num	src/sds.c	/^int __test_num = 0;$/;"	v
_add_buddies_to_roster	src/xmpp.c	/^static void _add_buddies_to_roster(XmppStream *stream, XmppStanza *stanza) $/;"	f	file:
_add_key	src/sasl.c	/^static char *_add_key(Hash *table, const char *key, $/;"	f	file:
_base64_charmap	src/sasl.c	/^static const char _base64_charmap[65] = {$/;"	v	file:
_base64_invcharmap	src/sasl.c	/^static const char _base64_invcharmap[256] = {$/;"	v	file:
_characters	src/parser.c	/^static void _characters(void *userdata, const XML_Char *s, int len) {$/;"	f	file:
_digest_to_hex	src/sasl.c	/^static void _digest_to_hex(const char *digest, char *hex) {$/;"	f	file:
_end_element	src/parser.c	/^static void _end_element(void *userdata, const XML_Char *name) {$/;"	f	file:
_handle_auth_failure	src/xmpp.c	/^static void _handle_auth_failure(XmppStream *stream, XmppStanza *stanza) $/;"	f	file:
_handle_auth_success	src/xmpp.c	/^static void _handle_auth_success(XmppStream *stream, XmppStanza *stanza) $/;"	f	file:
_handle_stream_end	src/xmpp.c	/^static void _handle_stream_end(char *name, void * const userdata) $/;"	f	file:
_handle_stream_errors	src/xmpp.c	/^static void _handle_stream_errors(XmppStream *stream, XmppStanza *stanza)$/;"	f	file:
_handle_stream_features	src/xmpp.c	/^static void _handle_stream_features(XmppStream *stream, XmppStanza *stanza) $/;"	f	file:
_handle_stream_stanza	src/xmpp.c	/^static void _handle_stream_stanza(XmppStanza * const stanza, void * const userdata) $/;"	f	file:
_handle_stream_start	src/xmpp.c	/^static void _handle_stream_start(char *name, char **attrs, void *userdata) $/;"	f	file:
_handle_xmpp_iq	src/xmpp.c	/^static void _handle_xmpp_iq(XmppStream *stream, XmppStanza *iq) $/;"	f	file:
_handle_xmpp_message	src/xmpp.c	/^static void _handle_xmpp_message(XmppStream *stream, XmppStanza *message) $/;"	f	file:
_handle_xmpp_presence	src/xmpp.c	/^static void _handle_xmpp_presence(XmppStream *stream, XmppStanza *presence) $/;"	f	file:
_hash_iterator_t	src/hash.c	/^struct _hash_iterator_t {$/;"	s	file:
_hash_key	src/hash.c	/^static int _hash_key(Hash *table, const char *key)$/;"	f	file:
_hashentry_t	src/hash.c	/^struct _hashentry_t {$/;"	s	file:
_log	src/logger.c	/^void _log(LogLevel level, const char *category, const char *format, va_list ap) {$/;"	f
_make_quoted	src/sasl.c	/^static char *_make_quoted(const char *s) {$/;"	f	file:
_make_sasl_auth	src/xmpp.c	/^static XmppStanza *_make_sasl_auth(const char *mechanism) $/;"	f	file:
_make_starttls	src/xmpp.c	/^static XmppStanza *_make_starttls(XmppStream *stream) $/;"	f	file:
_make_string	src/sasl.c	/^static char *_make_string(const char *s, const unsigned len) {$/;"	f	file:
_parse_digest_challenge	src/sasl.c	/^static Hash *_parse_digest_challenge(const char *msg)$/;"	f	file:
_remove_callback_from_list	src/xmpp.c	/^static void _remove_callback_from_list(list *callbacks, void *callback) $/;"	f	file:
_render_stanza_recursive	src/stanza.c	/^static int _render_stanza_recursive(XmppStanza *stanza,$/;"	f	file:
_render_update	src/stanza.c	/^static inline void _render_update($/;"	f	file:
_rfds	src/ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_set_attributes	src/parser.c	/^static void _set_attributes(XmppStanza *stanza, const XML_Char **attrs) {$/;"	f	file:
_start_element	src/parser.c	/^static void _start_element(void *userdata,$/;"	f	file:
_wfds	src/ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_xmpp_stream_auth	src/xmpp.c	/^static void _xmpp_stream_auth(XmppStream * const stream, XmppStanza *mechanisms) $/;"	f	file:
_xmpp_stream_bind	src/xmpp.c	/^static void _xmpp_stream_bind(XmppStream *stream, XmppStanza *bind) $/;"	f	file:
_xmpp_stream_bind_callback	src/xmpp.c	/^static void _xmpp_stream_bind_callback(XmppStream *stream, XmppStanza *iq) {$/;"	f	file:
_xmpp_stream_closed	src/xmpp.c	/^static void _xmpp_stream_closed(XmppStream *stream) $/;"	f	file:
_xmpp_stream_roster	src/xmpp.c	/^static void _xmpp_stream_roster(XmppStream *stream) $/;"	f	file:
_xmpp_stream_roster_callback	src/xmpp.c	/^static void _xmpp_stream_roster_callback(XmppStream *stream, XmppStanza *stanza) $/;"	f	file:
_xmpp_stream_session	src/xmpp.c	/^static void _xmpp_stream_session(XmppStream *stream) $/;"	f	file:
_xmpp_stream_session_callback	src/xmpp.c	/^static void _xmpp_stream_session_callback(XmppStream *stream, XmppStanza *iq) $/;"	f	file:
_xmpp_stream_starttls	src/xmpp.c	/^static void _xmpp_stream_starttls(XmppStream *stream, XmppStanza *tlsFeature) $/;"	f	file:
aeAddMillisecondsToNow	src/ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	file:
aeApiAddEvent	src/ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	src/ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	src/ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiCreate	src/ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	src/ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	src/ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiDelEvent	src/ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:
aeApiDelEvent	src/ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	src/ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiFree	src/ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	src/ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	src/ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiName	src/ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	src/ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	src/ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiPoll	src/ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	src/ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	src/ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiState	src/ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	src/ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	src/ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	src/ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	src/ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	src/ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeBeforeSleepProc	src/ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t
aeCreateEventLoop	src/ae.c	/^aeEventLoop *aeCreateEventLoop(void) {$/;"	f
aeCreateFileEvent	src/ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f
aeCreateTimeEvent	src/ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f
aeDeleteEventLoop	src/ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f
aeDeleteFileEvent	src/ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f
aeDeleteTimeEvent	src/ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f
aeEventFinalizerProc	src/ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	src/ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	src/ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeFileEvent	src/ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	src/ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileProc	src/ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	src/ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	src/ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeGetApiName	src/ae.c	/^char *aeGetApiName(void) {$/;"	f
aeGetTime	src/ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	file:
aeMain	src/ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f
aeProcessEvents	src/ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f
aeSearchNearestTimer	src/ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	file:
aeSetBeforeSleepProc	src/ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f
aeStop	src/ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f
aeTimeEvent	src/ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	src/ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeProc	src/ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeWait	src/ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f
anetCreateSocket	src/anet.c	/^static int anetCreateSocket(char *err, int domain) {$/;"	f	file:
anetGenericAccept	src/anet.c	/^static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {$/;"	f	file:
anetListen	src/anet.c	/^static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len) {$/;"	f	file:
anetNonBlock	src/anet.c	/^int anetNonBlock(char *err, int fd)$/;"	f
anetPeerToString	src/anet.c	/^int anetPeerToString(int fd, char *ip, int *port) {$/;"	f
anetRead	src/anet.c	/^int anetRead(int fd, char *buf, int count)$/;"	f
anetResolve	src/anet.c	/^int anetResolve(char *err, char *host, char *ipbuf)$/;"	f
anetSetError	src/anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	file:
anetSetSendBuffer	src/anet.c	/^int anetSetSendBuffer(char *err, int fd, int buffsize)$/;"	f
anetTcpAccept	src/anet.c	/^int anetTcpAccept(char *err, int s, char *ip, int *port) {$/;"	f
anetTcpConnect	src/anet.c	/^int anetTcpConnect(char *err, char *addr, int port)$/;"	f
anetTcpGenericConnect	src/anet.c	/^static int anetTcpGenericConnect(char *err, char *addr, int port, int flags)$/;"	f	file:
anetTcpKeepAlive	src/anet.c	/^int anetTcpKeepAlive(char *err, int fd)$/;"	f
anetTcpNoDelay	src/anet.c	/^int anetTcpNoDelay(char *err, int fd)$/;"	f
anetTcpNonBlockConnect	src/anet.c	/^int anetTcpNonBlockConnect(char *err, char *addr, int port)$/;"	f
anetTcpServer	src/anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr)$/;"	f
anetUdpSend	src/anet.c	/^int anetUdpSend(char *addr, int port, char *buf, int count) $/;"	f
anetUdpServer	src/anet.c	/^int anetUdpServer(char *err, char *bindaddr, int port)$/;"	f
anetUnixAccept	src/anet.c	/^int anetUnixAccept(char *err, int s) {$/;"	f
anetUnixConnect	src/anet.c	/^int anetUnixConnect(char *err, char *path)$/;"	f
anetUnixGenericConnect	src/anet.c	/^int anetUnixGenericConnect(char *err, char *path, int flags)$/;"	f
anetUnixNonBlockConnect	src/anet.c	/^int anetUnixNonBlockConnect(char *err, char *path)$/;"	f
anetUnixServer	src/anet.c	/^int anetUnixServer(char *err, char *path, mode_t perm)$/;"	f
anetWrite	src/anet.c	/^int anetWrite(int fd, char *buf, int count)$/;"	f
aof_fsync	src/config.h	/^#define aof_fsync /;"	d
apidata	src/ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop
apikey	src/smarta.h	/^    char *apikey;$/;"	m	struct:_Smarta
attributes	src/stanza.h	/^    Hash *attributes;$/;"	m	struct:_XmppStanza
authenticated	src/xmpp.h	/^    int authenticated;$/;"	m	struct:_XmppStream
base64_decode	src/sasl.c	/^unsigned char *base64_decode(const char * const buffer, const unsigned len) {$/;"	f
base64_decoded_len	src/sasl.c	/^int base64_decoded_len(const char * const buffer, const unsigned len) {$/;"	f
base64_encode	src/sasl.c	/^char *base64_encode(const unsigned char * const buffer, const unsigned len) {$/;"	f
base64_encoded_len	src/sasl.c	/^int base64_encoded_len(const unsigned len) {$/;"	f
before_sleep	src/smarta.c	/^static void before_sleep(struct aeEventLoop *eventLoop) {$/;"	f	file:
beforesleep	src/ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop
bits	src/md5.h	/^	uint32_t bits[2];$/;"	m	struct:MD5Context
blk	src/sha1.c	/^#define blk(/;"	d	file:
blk0	src/sha1.c	/^#define blk0(/;"	d	file:
body	src/event.h	/^    char *body;$/;"	m	struct:_Event
buddies	src/smarta.h	/^    list *buddies;$/;"	m	struct:_Smarta
buddy_new	src/xmpp.c	/^static Buddy *buddy_new() $/;"	f	file:
buddy_release	src/xmpp.c	/^static void buddy_release(void *p) $/;"	f	file:
buf	src/md5.h	/^	uint32_t buf[4];$/;"	m	struct:MD5Context
buf	src/sds.h	/^    char buf[];$/;"	m	struct:sdshdr
buffer	src/sha1.h	/^    uint8_t  buffer[64];$/;"	m	struct:__anon2
check_service	src/smarta.c	/^int check_service(struct aeEventLoop *el, long long id, void *clientdata) {$/;"	f
children	src/stanza.h	/^    struct _XmppStanza *children;$/;"	m	struct:_XmppStanza	typeref:struct:_XmppStanza::_XmppStanza
clientData	src/ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent
clientData	src/ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent
cmdusage	src/smarta.h	/^    char *cmdusage;$/;"	m	struct:_Smarta
collectd	src/smarta.h	/^    int collectd;$/;"	m	struct:_Smarta
collectd_port	src/smarta.h	/^    int collectd_port;$/;"	m	struct:_Smarta
command	src/smarta.h	/^    char *command;$/;"	m	struct:_Service
command_handler	src/smarta.c	/^static void command_handler(XmppStream *stream, XmppStanza *stanza) $/;"	f	file:
commands	src/smarta.h	/^    list *commands;$/;"	m	struct:_Smarta
conn_callback	src/xmpp.h	/^typedef void (*conn_callback)(XmppStream *stream, XmppStreamState state);$/;"	t
conn_callbacks	src/xmpp.h	/^    list *conn_callbacks;$/;"	m	struct:_XmppStream
conn_handler	src/smarta.c	/^static void conn_handler(XmppStream *stream, XmppStreamState state) $/;"	f	file:
connect_timeout	src/xmpp.h	/^    unsigned int connect_timeout;$/;"	m	struct:_XmppStream
count	src/sha1.h	/^    uint32_t count[2];$/;"	m	struct:__anon2
create_pid_file	src/smarta.c	/^static void create_pid_file(void) {$/;"	f	file:
daemonize	src/smarta.c	/^static void daemonize(void) {$/;"	f	file:
daemonize	src/smarta.h	/^    int daemonize;$/;"	m	struct:_Smarta
data	src/stanza.h	/^    char *data;$/;"	m	struct:_XmppStanza
decrement_used_memory	src/zmalloc.c	/^#define decrement_used_memory(/;"	d	file:
depth	src/parser.h	/^    int depth;$/;"	m	struct:_Parser
digest_to_hex	src/sha1.c	/^void digest_to_hex(const uint8_t digest[SHA1_DIGEST_SIZE], char *output) {$/;"	f
direction	src/list.h	/^    int direction;$/;"	m	struct:listIter
domain	src/xmpp.h	/^    char *domain;$/;"	m	struct:_XmppStream
dup	src/list.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:list
el	src/smarta.h	/^    aeEventLoop *el;$/;"	m	struct:_Smarta
endcb	src/parser.h	/^    parser_end_callback endcb;$/;"	m	struct:_Parser
entries	src/hash.c	/^    hashentry_t **entries;$/;"	m	struct:_Hash	file:
entry	src/hash.c	/^    hashentry_t *entry;$/;"	m	struct:_hash_iterator_t	file:
epfd	src/ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:
error	src/xmpp.h	/^    int error;$/;"	m	struct:_XmppStream
event_free	src/event.c	/^void event_free(Event *event) $/;"	f
event_has_heads	src/event.c	/^int event_has_heads(Event *event) $/;"	f
event_heads_to_string	src/event.c	/^sds event_heads_to_string(Event *event)$/;"	f
event_metrics_to_string	src/event.c	/^sds event_metrics_to_string(Event *event)$/;"	f
event_new	src/event.c	/^Event *event_new() $/;"	f
event_parse	src/event.c	/^Event *event_parse(char *buf) $/;"	f
event_to_string	src/smarta.c	/^static char *event_to_string(Event *event) $/;"	f	file:
events	src/ae.h	/^    aeFileEvent events[AE_SETSIZE]; \/* Registered events *\/$/;"	m	struct:aeEventLoop
events	src/ae_epoll.c	/^    struct epoll_event events[AE_SETSIZE];$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:
events	src/ae_kqueue.c	/^    struct kevent events[AE_SETSIZE];$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:
events	src/smarta.h	/^    Hash *events;$/;"	m	struct:_Smarta
events	src/xmpp.h	/^    Hash *events;$/;"	m	struct:_XmppStream
execute	src/smarta.c	/^static sds execute(char *incmd)$/;"	f	file:
expat	src/parser.h	/^    XML_Parser expat;$/;"	m	struct:_Parser
fd	src/ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent
fd	src/slave.h	/^    int fd;$/;"	m	struct:_Slave
fd	src/xmpp.h	/^    int fd; \/\/socket$/;"	m	struct:_XmppStream
finalizerProc	src/ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent
find_command	src/smarta.c	/^static Command *find_command(char *usage)$/;"	f	file:
fired	src/ae.h	/^    aeFiredEvent fired[AE_SETSIZE]; \/* Fired events *\/$/;"	m	struct:aeEventLoop
free	src/list.h	/^    void (*free)(void *ptr);$/;"	m	struct:list
free	src/sds.h	/^    int free;$/;"	m	struct:sdshdr
free_fun	src/hash.c	/^    hash_free_func free_fun;$/;"	m	struct:_Hash	file:
handle_check_result	src/smarta.c	/^void handle_check_result(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f
hash_add	src/hash.c	/^int hash_add(Hash *table, const char * const key, void *data)$/;"	f
hash_clone	src/hash.c	/^Hash *hash_clone(Hash * const table)$/;"	f
hash_drop	src/hash.c	/^int hash_drop(Hash *table, const char *key)$/;"	f
hash_free_func	src/hash.h	/^typedef void (*hash_free_func)(void *p);$/;"	t
hash_get	src/hash.c	/^void *hash_get(Hash *table, const char *key)$/;"	f
hash_iter_new	src/hash.c	/^hash_iterator_t *hash_iter_new(Hash *table)$/;"	f
hash_iter_next	src/hash.c	/^const char * hash_iter_next(hash_iterator_t *iter)$/;"	f
hash_iter_release	src/hash.c	/^void hash_iter_release(hash_iterator_t *iter)$/;"	f
hash_iterator_t	src/hash.h	/^typedef struct _hash_iterator_t hash_iterator_t;$/;"	t	typeref:struct:_hash_iterator_t
hash_new	src/hash.c	/^Hash *hash_new(const int size, hash_free_func free_fun)$/;"	f
hash_num_keys	src/hash.c	/^int hash_num_keys(Hash *table)$/;"	f
hash_release	src/hash.c	/^void hash_release(Hash * const table)$/;"	f
hashentry_t	src/hash.c	/^typedef struct _hashentry_t hashentry_t;$/;"	t	typeref:struct:_hashentry_t	file:
head	src/list.h	/^    listNode *head;$/;"	m	struct:list
heads	src/event.h	/^    list *heads;$/;"	m	struct:_Event
heartbeat	src/smarta.h	/^    int heartbeat;$/;"	m	struct:_Smarta
id	src/ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent
in	src/md5.h	/^	unsigned char in[64];$/;"	m	struct:MD5Context
increment_used_memory	src/zmalloc.c	/^#define increment_used_memory(/;"	d	file:
index	src/hash.c	/^    int index;$/;"	m	struct:_hash_iterator_t	file:
int16_t	src/sasl.c	/^  typedef short int               int16_t;$/;"	t	file:
int16_t	src/sha1.c	/^  typedef short int               int16_t;$/;"	t	file:
int32_t	src/sasl.c	/^  typedef int                     int32_t;$/;"	t	file:
int32_t	src/sha1.c	/^  typedef int                     int32_t;$/;"	t	file:
int64_t	src/sasl.c	/^  typedef __int64                 int64_t;$/;"	t	file:
int64_t	src/sha1.c	/^  typedef __int64                 int64_t;$/;"	t	file:
int8_t	src/sasl.c	/^  typedef signed char             int8_t;$/;"	t	file:
int8_t	src/sha1.c	/^  typedef signed char             int8_t;$/;"	t	file:
ip	src/slave.h	/^    char *ip;$/;"	m	struct:_Slave
iq_callback	src/xmpp.h	/^typedef void (*iq_callback)(XmppStream *stream, XmppStanza *iq);$/;"	t
iq_id_callbacks	src/xmpp.h	/^    Hash *iq_id_callbacks;$/;"	m	struct:_XmppStream
iq_ns_callbacks	src/xmpp.h	/^    Hash *iq_ns_callbacks;$/;"	m	struct:_XmppStream
is_buddy	src/xmpp.c	/^static int is_buddy(XmppStream *stream, char *jid) $/;"	f	file:
is_valid	src/smarta.c	/^static int is_valid(const char *buf) $/;"	f	file:
is_valid_event	src/smarta.c	/^static int is_valid_event(Event *event) {$/;"	f	file:
isslave	src/smarta.h	/^    int isslave;$/;"	m	struct:_Smarta
jid	src/xmpp.h	/^    char *jid;$/;"	m	struct:_Buddy
jid	src/xmpp.h	/^    char *jid;$/;"	m	struct:_XmppStream
key	src/hash.c	/^    char *key;$/;"	m	struct:_hashentry_t	file:
kqfd	src/ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:
len	src/list.h	/^    unsigned int len;$/;"	m	struct:list
len	src/sds.h	/^    int len;$/;"	m	struct:sdshdr
length	src/hash.c	/^    int length;$/;"	m	struct:_Hash	file:
list	src/list.h	/^typedef struct list {$/;"	s
list	src/list.h	/^} list;$/;"	t	typeref:struct:list
listAddNodeHead	src/list.c	/^list *listAddNodeHead(list *list, void *value)$/;"	f
listAddNodeTail	src/list.c	/^list *listAddNodeTail(list *list, void *value)$/;"	f
listCreate	src/list.c	/^list *listCreate(void)$/;"	f
listDelNode	src/list.c	/^void listDelNode(list *list, listNode *node)$/;"	f
listDup	src/list.c	/^list *listDup(list *orig)$/;"	f
listFirst	src/list.h	/^#define listFirst(/;"	d
listGetDupMethod	src/list.h	/^#define listGetDupMethod(/;"	d
listGetFree	src/list.h	/^#define listGetFree(/;"	d
listGetIterator	src/list.c	/^listIter *listGetIterator(list *list, int direction)$/;"	f
listGetMatchMethod	src/list.h	/^#define listGetMatchMethod(/;"	d
listIndex	src/list.c	/^listNode *listIndex(list *list, int index) {$/;"	f
listInsertNode	src/list.c	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after) {$/;"	f
listIter	src/list.h	/^typedef struct listIter {$/;"	s
listIter	src/list.h	/^} listIter;$/;"	t	typeref:struct:listIter
listLast	src/list.h	/^#define listLast(/;"	d
listLength	src/list.h	/^#define listLength(/;"	d
listNext	src/list.c	/^listNode *listNext(listIter *iter)$/;"	f
listNextNode	src/list.h	/^#define listNextNode(/;"	d
listNode	src/list.h	/^typedef struct listNode {$/;"	s
listNode	src/list.h	/^} listNode;$/;"	t	typeref:struct:listNode
listNodeValue	src/list.h	/^#define listNodeValue(/;"	d
listPrevNode	src/list.h	/^#define listPrevNode(/;"	d
listRelease	src/list.c	/^void listRelease(list *list)$/;"	f
listReleaseIterator	src/list.c	/^void listReleaseIterator(listIter *iter) {$/;"	f
listRewind	src/list.c	/^void listRewind(list *list, listIter *li) {$/;"	f
listRewindTail	src/list.c	/^void listRewindTail(list *list, listIter *li) {$/;"	f
listSearchKey	src/list.c	/^listNode *listSearchKey(list *list, void *key)$/;"	f
listSetDupMethod	src/list.h	/^#define listSetDupMethod(/;"	d
listSetFreeMethod	src/list.h	/^#define listSetFreeMethod(/;"	d
listSetMatchMethod	src/list.h	/^#define listSetMatchMethod(/;"	d
log_file	src/logger.c	/^char *log_file;$/;"	v
log_level	src/logger.c	/^int log_level;$/;"	v
logfile	src/smarta.h	/^    char *logfile;$/;"	m	struct:_Smarta
logger_debug	src/logger.c	/^void logger_debug(const char *category, const char *format, ...) {$/;"	f
logger_error	src/logger.c	/^void logger_error(const char *category, const char *format, ...) {$/;"	f
logger_fatal	src/logger.c	/^void logger_fatal(const char *category, const char *format, ...) {$/;"	f
logger_info	src/logger.c	/^void logger_info(const char *category, const char *format, ...) {$/;"	f
logger_warning	src/logger.c	/^void logger_warning(const char *category, const char *format, ...) {$/;"	f
main	src/sds.c	/^int main(void) {$/;"	f
main	src/sha1.c	/^int main(int argc, char** argv) {$/;"	f
main	src/smarta.c	/^int main(int argc, char **argv) {$/;"	f
mask	src/ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent
mask	src/ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent
masterauth	src/smarta.h	/^    char *masterauth;$/;"	m	struct:_Smarta
masterfd	src/smarta.h	/^    int masterfd;$/;"	m	struct:_Smarta
masterhost	src/smarta.h	/^    char *masterhost;$/;"	m	struct:_Smarta
masterport	src/smarta.h	/^    int masterport;$/;"	m	struct:_Smarta
match	src/list.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:list
maxfd	src/ae.h	/^    int maxfd;$/;"	m	struct:aeEventLoop
message_callback	src/xmpp.h	/^typedef void (*message_callback)(XmppStream *stream, XmppStanza *message);$/;"	t
message_callbacks	src/xmpp.h	/^    list *message_callbacks;$/;"	m	struct:_XmppStream
name	src/smarta.h	/^    char *name;$/;"	m	struct:_Service
name	src/smarta.h	/^    char *name;$/;"	m	struct:_Smarta
name	src/xmpp.h	/^    char *name;$/;"	m	struct:_Buddy
neterr	src/smarta.h	/^    char neterr[1024];$/;"	m	struct:_Smarta
next	src/ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
next	src/hash.c	/^    hashentry_t *next;$/;"	m	struct:_hashentry_t	file:
next	src/list.h	/^    listNode *next;$/;"	m	struct:listIter
next	src/list.h	/^    struct listNode *next;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
next	src/stanza.h	/^    struct _XmppStanza *next;$/;"	m	struct:_XmppStanza	typeref:struct:_XmppStanza::_XmppStanza
num_keys	src/hash.c	/^    int num_keys;$/;"	m	struct:_Hash	file:
parent	src/stanza.h	/^    struct _XmppStanza *parent;$/;"	m	struct:_XmppStanza	typeref:struct:_XmppStanza::_XmppStanza
parse_body	src/event.c	/^static void parse_body(Event *event, char *buf)$/;"	f	file:
parse_head_lines	src/event.c	/^static char *parse_head_lines(Event *event, char *buf)$/;"	f	file:
parse_status	src/event.c	/^static void parse_status(Event *event, char *start, char *end)$/;"	f	file:
parse_status_line	src/event.c	/^static char *parse_status_line(Event *event, char *buf)$/;"	f	file:
parser	src/xmpp.h	/^    Parser *parser;$/;"	m	struct:_XmppStream
parser_end_callback	src/parser.h	/^typedef void (*parser_end_callback)($/;"	t
parser_feed	src/parser.c	/^int parser_feed(Parser *parser, char *chunk, int len) {$/;"	f
parser_free	src/parser.c	/^void parser_free(Parser *parser) {$/;"	f
parser_new	src/parser.c	/^Parser *parser_new(parser_start_callback startcb,$/;"	f
parser_reset	src/parser.c	/^int parser_reset(Parser *parser) {$/;"	f
parser_stanza_callback	src/parser.h	/^typedef void (*parser_stanza_callback)($/;"	t
parser_start_callback	src/parser.h	/^typedef void (*parser_start_callback)($/;"	t
pass	src/xmpp.h	/^    char *pass;$/;"	m	struct:_XmppStream
period	src/smarta.h	/^    long period;$/;"	m	struct:_Service
pidfile	src/smarta.h	/^    char *pidfile;$/;"	m	struct:_Smarta
port	src/slave.h	/^    int port;$/;"	m	struct:_Slave
port	src/xmpp.h	/^    int port;$/;"	m	struct:_XmppStream
prepare_reset	src/xmpp.h	/^    int prepare_reset;$/;"	m	struct:_XmppStream
presence_callback	src/xmpp.h	/^typedef void (*presence_callback)(XmppStream *stream, XmppStanza *presence);$/;"	t
presence_callbacks	src/xmpp.h	/^    list *presence_callbacks;$/;"	m	struct:_XmppStream
presence_handler	src/smarta.c	/^static void presence_handler(XmppStream *stream, XmppStanza *presence) $/;"	f	file:
presences	src/xmpp.h	/^    list *presences;$/;"	m	struct:_XmppStream
prev	src/list.h	/^    struct listNode *prev;$/;"	m	struct:listNode	typeref:struct:listNode::listNode
prev	src/stanza.h	/^    struct _XmppStanza *prev;$/;"	m	struct:_XmppStanza	typeref:struct:_XmppStanza::_XmppStanza
processTimeEvents	src/ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:
read_from_slave	src/slave.c	/^static void read_from_slave(aeEventLoop *el, int fd, void *privdata, int mask) $/;"	f	file:
read_from_xmpp	src/slave.c	/^static void read_from_xmpp(aeEventLoop *el, int fd, void *privdata, int mask) $/;"	f	file:
ref	src/hash.c	/^    unsigned int ref;$/;"	m	struct:_Hash	file:
ref	src/hash.c	/^    unsigned int ref;$/;"	m	struct:_hash_iterator_t	file:
ref	src/stanza.h	/^    int ref;$/;"	m	struct:_XmppStanza
retries	src/xmpp.h	/^    int retries;$/;"	m	struct:_XmppStream
rfds	src/ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
rfileProc	src/ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent
rol	src/sha1.c	/^#define rol(/;"	d	file:
roster	src/xmpp.h	/^    Hash *roster;$/;"	m	struct:_XmppStream
sasl_digest_md5	src/sasl.c	/^char *sasl_digest_md5(const char *challenge,$/;"	f
sasl_plain	src/sasl.c	/^char *sasl_plain(const char *authid, const char *password) {$/;"	f
sasl_support	src/xmpp.h	/^    int sasl_support; $/;"	m	struct:_XmppStream
sched_checks	src/smarta.c	/^static void sched_checks() {$/;"	f	file:
sds	src/sds.h	/^typedef char *sds;$/;"	t
sdsMakeRoomFor	src/sds.c	/^static sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f	file:
sdsOomAbort	src/sds.c	/^static void sdsOomAbort(void) {$/;"	f	file:
sdsavail	src/sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdscat	src/sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatlen	src/sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	src/sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	src/sds.c	/^sds sdscatrepr(sds s, char *p, size_t len) {$/;"	f
sdscatvprintf	src/sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdscmp	src/sds.c	/^int sdscmp(sds s1, sds s2) {$/;"	f
sdscpy	src/sds.c	/^sds sdscpy(sds s, char *t) {$/;"	f
sdscpylen	src/sds.c	/^sds sdscpylen(sds s, char *t, size_t len) {$/;"	f
sdsdup	src/sds.c	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	src/sds.c	/^sds sdsempty(void) {$/;"	f
sdsfree	src/sds.c	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	src/sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	src/sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	src/sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdshdr	src/sds.h	/^struct sdshdr {$/;"	s
sdsjoin	src/sds.c	/^sds sdsjoin(sds *tokens, int size)$/;"	f
sdslen	src/sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdsnew	src/sds.c	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	src/sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	src/sds.c	/^sds sdsrange(sds s, int start, int end) {$/;"	f
sdssplitargs	src/sds.c	/^sds *sdssplitargs(char *line, int *argc) {$/;"	f
sdssplitargswithquotes	src/sds.c	/^sds *sdssplitargswithquotes(char *line, int *argc) {$/;"	f
sdssplitlen	src/sds.c	/^sds *sdssplitlen(char *s, int len, char *sep, int seplen, int *count) {$/;"	f
sdstolower	src/sds.c	/^void sdstolower(sds s) {$/;"	f
sdstoupper	src/sds.c	/^void sdstoupper(sds s) {$/;"	f
sdstrim	src/sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsupdatelen	src/sds.c	/^void sdsupdatelen(sds s) {$/;"	f
server	src/smarta.h	/^    char *server;$/;"	m	struct:_Smarta
server	src/xmpp.h	/^    char *server;$/;"	m	struct:_XmppStream
service	src/event.h	/^    char *service;$/;"	m	struct:_Event
services	src/smarta.h	/^    list *services;$/;"	m	struct:_Smarta
shell	src/smarta.h	/^    char *shell;$/;"	m	struct:_Command
should_emit	src/smarta.c	/^static int should_emit(XmppStream *stream, char *jid, Event *event) $/;"	f	file:
slave_accept_handler	src/slave.c	/^void slave_accept_handler(aeEventLoop *el, int listenfd, void *privdata, int mask)$/;"	f
slave_create	src/slave.c	/^static Slave *slave_create(int fd, int xmppfd) {$/;"	f	file:
slave_release	src/slave.c	/^static void slave_release(Slave *slave) $/;"	f	file:
slaveip	src/smarta.h	/^    char *slaveip;$/;"	m	struct:_Smarta
slaveport	src/smarta.h	/^    int slaveport;$/;"	m	struct:_Smarta
slaves	src/smarta.h	/^    list *slaves;$/;"	m	struct:_Smarta
smarta	src/smarta.c	/^Smarta smarta;$/;"	v
smarta_collectd_start	src/smarta.c	/^static void smarta_collectd_start(void)$/;"	f	file:
smarta_config	src/smarta.c	/^static void smarta_config(char *filename) {$/;"	f	file:
smarta_cron	src/smarta.c	/^static int smarta_cron(struct aeEventLoop *eventLoop,$/;"	f	file:
smarta_emit_event	src/smarta.c	/^static void smarta_emit_event(XmppStream *stream, Event *event) $/;"	f	file:
smarta_init	src/smarta.c	/^static void smarta_init() $/;"	f	file:
smarta_masterd_start	src/smarta.c	/^static void smarta_masterd_start(void) $/;"	f	file:
smarta_prepare	src/smarta.c	/^static void smarta_prepare() $/;"	f	file:
smarta_run	src/smarta.c	/^static void smarta_run() {$/;"	f	file:
smarta_xmpp_connect	src/smarta.c	/^static void smarta_xmpp_connect(void) $/;"	f	file:
sortlines	src/smarta.c	/^static void sortlines(void *lines, unsigned int len)$/;"	f	file:
stanza	src/parser.h	/^    XmppStanza *stanza;$/;"	m	struct:_Parser
stanza	src/xmpp.h	/^    XmppStanza *stanza;$/;"	m	struct:_XmppStreamError
stanzacb	src/parser.h	/^    parser_stanza_callback stanzacb;$/;"	m	struct:_Parser
startcb	src/parser.h	/^    parser_start_callback startcb;$/;"	m	struct:_Parser
stat_slaves	src/smarta.h	/^    int stat_slaves;$/;"	m	struct:_Smarta
state	src/sha1.h	/^    uint32_t state[5];$/;"	m	struct:__anon2
state	src/xmpp.h	/^    XmppStreamState state;$/;"	m	struct:_XmppStream
status	src/event.h	/^    char *status;$/;"	m	struct:_Event
stop	src/ae.h	/^    int stop;$/;"	m	struct:aeEventLoop
strcatnew	src/smarta.c	/^static char *strcatnew(char *s1, char *s2) $/;"	f	file:
strcompare	src/smarta.c	/^static int strcompare(const void *s1, const void *s2) $/;"	f	file:
stream	src/smarta.h	/^    XmppStream *stream;$/;"	m	struct:_Smarta
stream_error	src/xmpp.h	/^    XmppStreamError *stream_error;$/;"	m	struct:_XmppStream
stream_id	src/xmpp.h	/^    char *stream_id;$/;"	m	struct:_XmppStream
strequal	src/xmpp.c	/^static int strequal(const char* s1, const char *s2) $/;"	f	file:
strfree	src/event.c	/^static void strfree(void *s) {$/;"	f	file:
strmatch	src/xmpp.c	/^static int strmatch(void *s1, void *s2) $/;"	f	file:
sub	src/xmpp.h	/^    Subscription sub;$/;"	m	struct:_Buddy
subject	src/event.h	/^    char *subject;$/;"	m	struct:_Event
table	src/hash.c	/^    Hash *table;$/;"	m	struct:_hash_iterator_t	file:
tail	src/list.h	/^    listNode *tail;$/;"	m	struct:list
taskid	src/smarta.h	/^    long taskid;$/;"	m	struct:_Service
test_cond	src/sds.c	/^#define test_cond(/;"	d	file:
test_data	src/sha1.c	/^static char *test_data[] = {$/;"	v	file:
test_report	src/sds.c	/^#define test_report(/;"	d	file:
test_results	src/sha1.c	/^static char *test_results[] = {$/;"	v	file:
text	src/xmpp.h	/^    char *text;$/;"	m	struct:_XmppStreamError
timeEventHead	src/ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop
timeEventNextId	src/ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop
timeProc	src/ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent
timeout_stamp	src/xmpp.h	/^    uint64_t timeout_stamp;$/;"	m	struct:_XmppStream
tls_support	src/xmpp.h	/^    int tls_support;$/;"	m	struct:_XmppStream
type	src/stanza.h	/^    XmppStanzaType type;$/;"	m	struct:_XmppStanza
type	src/xmpp.h	/^    XmppErrorType type;$/;"	m	struct:_XmppStreamError
uint16_t	src/sasl.c	/^  typedef unsigned short int        uint16_t;$/;"	t	file:
uint16_t	src/sha1.c	/^  typedef unsigned short int        uint16_t;$/;"	t	file:
uint32_t	src/md5.h	/^  typedef unsigned int              uint32_t;$/;"	t
uint32_t	src/sasl.c	/^  typedef unsigned int              uint32_t;$/;"	t	file:
uint32_t	src/sha1.c	/^  typedef unsigned int              uint32_t;$/;"	t	file:
uint8_t	src/sasl.c	/^  typedef unsigned char             uint8_t;$/;"	t	file:
uint8_t	src/sha1.c	/^  typedef unsigned char             uint8_t;$/;"	t	file:
usage	src/smarta.c	/^static void usage() $/;"	f	file:
usage	src/smarta.h	/^    char *usage;$/;"	m	struct:_Command
used_memory	src/zmalloc.c	/^static size_t used_memory = 0;$/;"	v	file:
userdata	src/parser.h	/^    void *userdata;$/;"	m	struct:_Parser
userdata	src/xmpp.h	/^    void *userdata;$/;"	m	struct:_XmppStream
value	src/hash.c	/^    void *value;$/;"	m	struct:_hashentry_t	file:
value	src/list.h	/^    void *value;$/;"	m	struct:listNode
verbosity	src/smarta.h	/^    int verbosity;$/;"	m	struct:_Smarta
version	src/smarta.c	/^static void version() $/;"	f	file:
wfds	src/ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
wfileProc	src/ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent
when_ms	src/ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent
when_sec	src/ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent
xmpp_add_conn_callback	src/xmpp.c	/^void xmpp_add_conn_callback(XmppStream *stream, conn_callback callback) $/;"	f
xmpp_add_iq_id_callback	src/xmpp.c	/^void xmpp_add_iq_id_callback(XmppStream *stream, char *iq_id, iq_callback callback) $/;"	f
xmpp_add_iq_ns_callback	src/xmpp.c	/^void xmpp_add_iq_ns_callback(XmppStream *stream, char *iq_ns, iq_callback callback) $/;"	f
xmpp_add_message_callback	src/xmpp.c	/^void xmpp_add_message_callback(XmppStream *stream, message_callback callback){$/;"	f
xmpp_add_presence_callback	src/xmpp.c	/^void xmpp_add_presence_callback(XmppStream *stream, presence_callback callback) $/;"	f
xmpp_attrs_get_value	src/stanza.c	/^char *xmpp_attrs_get_value(char **attrs, char *name) $/;"	f
xmpp_connect	src/xmpp.c	/^int xmpp_connect(aeEventLoop *el, XmppStream *stream)$/;"	f
xmpp_disconnect	src/xmpp.c	/^void xmpp_disconnect(aeEventLoop *el, XmppStream *stream) $/;"	f
xmpp_get_iq_id_callback	src/xmpp.c	/^iq_callback xmpp_get_iq_id_callback(XmppStream *stream, char *id) $/;"	f
xmpp_get_iq_ns_callback	src/xmpp.c	/^iq_callback xmpp_get_iq_ns_callback(XmppStream *stream, char *ns) $/;"	f
xmpp_jid_bare	src/jid.c	/^char *xmpp_jid_bare(const char *jid) {$/;"	f
xmpp_jid_bare_compare	src/jid.c	/^int xmpp_jid_bare_compare(const char *jid1, const char *jid2) $/;"	f
xmpp_jid_domain	src/jid.c	/^char *xmpp_jid_domain(const char *jid) {$/;"	f
xmpp_jid_new	src/jid.c	/^char *xmpp_jid_new(const char *node,$/;"	f
xmpp_jid_node	src/jid.c	/^char *xmpp_jid_node(const char *jid) {$/;"	f
xmpp_jid_resource	src/jid.c	/^char *xmpp_jid_resource(const char *jid) {$/;"	f
xmpp_read	src/xmpp.c	/^static void xmpp_read(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:
xmpp_reconnect	src/xmpp.c	/^static int xmpp_reconnect(aeEventLoop *el, long long id, void *clientData) $/;"	f	file:
xmpp_remove_conn_callback	src/xmpp.c	/^void xmpp_remove_conn_callback(XmppStream *stream, conn_callback callback) $/;"	f
xmpp_remove_iq_id_callback	src/xmpp.c	/^void xmpp_remove_iq_id_callback(XmppStream *stream, char *iq_id) $/;"	f
xmpp_remove_iq_ns_callback	src/xmpp.c	/^void xmpp_remove_iq_ns_callback(XmppStream *stream, char *iq_ns) $/;"	f
xmpp_remove_message_callback	src/xmpp.c	/^void xmpp_remove_message_callback(XmppStream *stream, message_callback callback) $/;"	f
xmpp_remove_presence_callback	src/xmpp.c	/^void xmpp_remove_presence_callback(XmppStream *stream, presence_callback callback) $/;"	f
xmpp_send_format	src/xmpp.c	/^void xmpp_send_format(XmppStream *stream, char *fmt, ...) $/;"	f
xmpp_send_message	src/xmpp.c	/^void xmpp_send_message(XmppStream *stream, const char *to, const char *data)$/;"	f
xmpp_send_stanza	src/xmpp.c	/^void xmpp_send_stanza(XmppStream *stream, XmppStanza *stanza) $/;"	f
xmpp_send_string	src/xmpp.c	/^void xmpp_send_string(XmppStream *stream, char *data, size_t len)$/;"	f
xmpp_stanza_add_child	src/stanza.c	/^int xmpp_stanza_add_child(XmppStanza *stanza, XmppStanza *child) {$/;"	f
xmpp_stanza_cdata	src/stanza.c	/^XmppStanza *xmpp_stanza_cdata(const char *data) $/;"	f
xmpp_stanza_clone	src/stanza.c	/^XmppStanza *xmpp_stanza_clone(XmppStanza *  stanza) {$/;"	f
xmpp_stanza_copy	src/stanza.c	/^XmppStanza *xmpp_stanza_copy(XmppStanza * stanza) {$/;"	f
xmpp_stanza_get_attribute	src/stanza.c	/^char *xmpp_stanza_get_attribute(XmppStanza *stanza,$/;"	f
xmpp_stanza_get_attribute_count	src/stanza.c	/^int xmpp_stanza_get_attribute_count(XmppStanza *stanza) {$/;"	f
xmpp_stanza_get_attributes	src/stanza.c	/^int xmpp_stanza_get_attributes(XmppStanza * const stanza,$/;"	f
xmpp_stanza_get_child_by_name	src/stanza.c	/^XmppStanza *xmpp_stanza_get_child_by_name(XmppStanza *stanza, char *name)$/;"	f
xmpp_stanza_get_child_by_ns	src/stanza.c	/^XmppStanza *xmpp_stanza_get_child_by_ns(XmppStanza *stanza, char *ns)$/;"	f
xmpp_stanza_get_children	src/stanza.c	/^XmppStanza *xmpp_stanza_get_children(XmppStanza *stanza) $/;"	f
xmpp_stanza_get_id	src/stanza.c	/^char *xmpp_stanza_get_id(XmppStanza *stanza)$/;"	f
xmpp_stanza_get_name	src/stanza.c	/^char *xmpp_stanza_get_name(XmppStanza *stanza) {$/;"	f
xmpp_stanza_get_next	src/stanza.c	/^XmppStanza *xmpp_stanza_get_next(XmppStanza *stanza)$/;"	f
xmpp_stanza_get_ns	src/stanza.c	/^char *xmpp_stanza_get_ns(XmppStanza *stanza)$/;"	f
xmpp_stanza_get_text	src/stanza.c	/^char *xmpp_stanza_get_text(XmppStanza *stanza)$/;"	f
xmpp_stanza_get_text_ptr	src/stanza.c	/^char *xmpp_stanza_get_text_ptr(XmppStanza *stanza)$/;"	f
xmpp_stanza_get_type	src/stanza.c	/^char *xmpp_stanza_get_type(XmppStanza *stanza)$/;"	f
xmpp_stanza_is_tag	src/stanza.c	/^int xmpp_stanza_is_tag(XmppStanza *stanza) {$/;"	f
xmpp_stanza_is_text	src/stanza.c	/^int xmpp_stanza_is_text(XmppStanza *stanza) {$/;"	f
xmpp_stanza_new	src/stanza.c	/^XmppStanza *xmpp_stanza_new() {$/;"	f
xmpp_stanza_release	src/stanza.c	/^int xmpp_stanza_release(XmppStanza *stanza) {$/;"	f
xmpp_stanza_set_attribute	src/stanza.c	/^int xmpp_stanza_set_attribute(XmppStanza *stanza,$/;"	f
xmpp_stanza_set_id	src/stanza.c	/^int xmpp_stanza_set_id(XmppStanza *stanza, char *id) {$/;"	f
xmpp_stanza_set_name	src/stanza.c	/^int xmpp_stanza_set_name(XmppStanza *stanza, const char *name) {$/;"	f
xmpp_stanza_set_ns	src/stanza.c	/^int xmpp_stanza_set_ns(XmppStanza *stanza, char *ns) {$/;"	f
xmpp_stanza_set_text	src/stanza.c	/^int xmpp_stanza_set_text(XmppStanza *stanza, char *text) {$/;"	f
xmpp_stanza_set_text_with_size	src/stanza.c	/^int xmpp_stanza_set_text_with_size(XmppStanza *stanza,$/;"	f
xmpp_stanza_set_type	src/stanza.c	/^int xmpp_stanza_set_type(XmppStanza *stanza,$/;"	f
xmpp_stanza_tag	src/stanza.c	/^XmppStanza *xmpp_stanza_tag(const char *name) $/;"	f
xmpp_stanza_text	src/stanza.c	/^XmppStanza *xmpp_stanza_text(const char *text) $/;"	f
xmpp_stanza_to_text	src/stanza.c	/^int xmpp_stanza_to_text($/;"	f
xmpp_stream_feed	src/xmpp.c	/^int xmpp_stream_feed(XmppStream *stream, char *buffer, int len) $/;"	f
xmpp_stream_get_jid	src/xmpp.c	/^char *xmpp_stream_get_jid(XmppStream *stream) $/;"	f
xmpp_stream_get_pass	src/xmpp.c	/^char *xmpp_stream_get_pass(XmppStream *stream) {$/;"	f
xmpp_stream_new	src/xmpp.c	/^XmppStream *xmpp_stream_new() $/;"	f
xmpp_stream_open	src/xmpp.c	/^int xmpp_stream_open(XmppStream *stream) $/;"	f
xmpp_stream_set_jid	src/xmpp.c	/^void xmpp_stream_set_jid(XmppStream *stream, const char *jid) $/;"	f
xmpp_stream_set_pass	src/xmpp.c	/^void xmpp_stream_set_pass(XmppStream *stream, const char *pass) {$/;"	f
xmpp_stream_set_port	src/xmpp.c	/^void xmpp_stream_set_port(XmppStream *stream, int port) {$/;"	f
xmpp_stream_set_server	src/xmpp.c	/^void xmpp_stream_set_server(XmppStream *stream, const char *server) $/;"	f
xmpp_stream_set_state	src/xmpp.c	/^void xmpp_stream_set_state(XmppStream *stream, int state)  $/;"	f
xmppfd	src/slave.h	/^    int xmppfd;$/;"	m	struct:_Slave
yesnotoi	src/smarta.c	/^static int yesnotoi(char *s) {$/;"	f	file:
zfree	src/zmalloc.c	/^void zfree(void *ptr) {$/;"	f
zmalloc	src/zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f
zmalloc_oom	src/zmalloc.c	/^static void zmalloc_oom(size_t size) {$/;"	f	file:
zmalloc_used_memory	src/zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f
zrealloc	src/zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f
zstrdup	src/zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f
